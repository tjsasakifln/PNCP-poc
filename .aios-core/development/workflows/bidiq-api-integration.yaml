workflow:
  id: bidiq-api-integration
  name: BidIQ API Integration - Resilience Pattern
  description: >-
    Workflow para integração de nova API externa seguindo o padrão de resiliência do PNCP client.
    Inclui retry com exponential backoff, rate limiting, circuit breaker e paginação automática.
    Baseado no padrão comprovado em pncp_client.py.
  type: brownfield
  project_types:
    - api-integration
    - external-service
    - resilience-pattern

  sequence:
    - step: api_architecture_design
      phase: 1
      phase_name: "Análise e Design do Client"
      agent: architect
      action: analyze_api_design_client
      creates: docs/architecture/api-client-design.md
      notes: |
        @architect analisa a documentação da API externa e projeta o client:

        RESPONSABILIDADES:
        1. Analisar documentação da API (endpoints, autenticação, rate limits)
        2. Definir estratégia de retry (base delay, max retries, jitter)
        3. Mapear rate limits e definir throttling
        4. Projetar error handling (códigos HTTP, timeouts, circuit breaker)
        5. Definir estratégia de paginação (offset, cursor, token)
        6. Documentar contrato de dados (request/response)

        REFERÊNCIA: backend/pncp_client.py (padrão existente)
        - Exponential backoff: base 2s, max 60s
        - Rate limiting: 10 req/s
        - Circuit breaker pattern
        - Generator pattern para paginação

        OUTPUT: docs/architecture/api-client-design.md

    - step: implement_http_client
      phase: 2
      phase_name: "Implementação do HTTP Client"
      agent: dev
      action: implement_resilient_client
      requires: docs/architecture/api-client-design.md
      creates: backend/new_client.py
      notes: |
        @dev implementa o HTTP client resiliente com httpx:

        COMPONENTES:
        1. Classe client com httpx.AsyncClient
        2. Exponential backoff com jitter (retry decorator)
        3. Rate limiter (asyncio.Semaphore ou similar)
        4. Circuit breaker (estados: closed, open, half-open)
        5. Timeout configuration (connect, read, pool)
        6. Logging estruturado para debugging

        PADRÃO: Seguir pncp_client.py
        - Retry: max 5 tentativas, backoff exponencial
        - Rate limit: respeitar header Retry-After (429)
        - Timeout: 30s por request
        - 100ms mínimo entre requests

        OUTPUT: backend/<nome>_client.py

    - step: implement_models_and_endpoints
      phase: 3
      phase_name: "Modelos e Integração"
      agent: dev
      action: implement_schemas_endpoints
      requires: backend/new_client.py
      creates:
        - backend/schemas.py (atualizado)
        - backend/main.py (atualizado)
      notes: |
        @dev implementa modelos Pydantic e endpoints FastAPI:

        COMPONENTES:
        1. Pydantic models para request/response da API
        2. Validação de campos (Pattern, Field constraints)
        3. Endpoint FastAPI integrando o client
        4. Error handling com HTTPException apropriado
        5. Paginação automática via generator (fetch_all pattern)

        PADRÃO: Seguir schemas.py existente
        - Type hints em todas as funções
        - Docstrings Google style
        - Pydantic 2.6+ validation

        OUTPUT: Modelos e endpoints integrados

    - step: unit_tests
      phase: 4
      phase_name: "Testes Unitários"
      agent: qa
      action: create_unit_tests
      requires:
        - backend/new_client.py
        - backend/schemas.py
      creates: backend/tests/test_new_client.py
      notes: |
        @qa cria testes unitários para o client:

        COBERTURA OBRIGATÓRIA:
        1. Retry logic (sucesso após N falhas, max retries exceeded)
        2. Rate limiting (respeita delay, header Retry-After)
        3. Error handling (timeout, 4xx, 5xx, connection error)
        4. Paginação (página única, múltiplas páginas, página vazia)
        5. Circuit breaker (open, half-open, close transitions)
        6. Validação de modelos Pydantic

        PADRÃO: Seguir test_pncp_client.py
        - pytest com mocks (httpx mock transport)
        - Coverage >= 70%
        - Assertions específicas por cenário

        OUTPUT: backend/tests/test_<nome>_client.py

    - step: integration_tests
      phase: 5
      phase_name: "Testes de Integração"
      agent: qa
      action: create_integration_tests
      requires: backend/tests/test_new_client.py
      creates: backend/tests/test_integration_new_client.py
      notes: |
        @qa cria testes de integração com API mockada:

        CENÁRIOS:
        1. Fluxo completo: request → retry → success → parse
        2. Fluxo com paginação: multiple pages → aggregated result
        3. Fluxo de falha: API indisponível → circuit breaker → fallback
        4. Fluxo de rate limit: 429 → backoff → retry → success
        5. Edge cases: resposta vazia, dados malformados, timeout

        PADRÃO: Mock responses realistas baseados na API
        - @pytest.mark.integration para testes com API real
        - Fixtures compartilhadas para responses mockadas
        - Verificar cobertura total >= 70%

        OUTPUT: backend/tests/test_integration_<nome>.py

  decision_guidance:
    when_to_use:
      - Integrar nova API externa ao backend
      - Substituir ou modernizar client HTTP existente
      - Adicionar resiliência a chamada de serviço externo
      - Implementar padrão retry/circuit breaker
      - API instável que requer tratamento robusto de falhas

  handoff_prompts:
    architecture_complete: |
      Design do client concluído: docs/architecture/api-client-design.md

      Próximo: @dev para implementação do HTTP client (FASE 2)
      Referência: backend/pncp_client.py para padrões de resiliência

    client_complete: |
      HTTP client implementado com retry, rate limiting e circuit breaker.

      Próximo: @dev para modelos Pydantic e endpoints FastAPI (FASE 3)

    implementation_complete: |
      Client, modelos e endpoints implementados.

      Próximo: @qa para testes unitários (FASE 4)
      Referência: backend/tests/test_pncp_client.py para padrões de teste

    tests_complete: |
      Testes unitários e de integração completos.
      Coverage >= 70% verificado.

      API integration pronta para code review e merge.
