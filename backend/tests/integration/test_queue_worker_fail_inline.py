"""AC12: Queue dispatch succeeds but worker job fails.

Tests the scenario where:
1. is_queue_available() returns True
2. enqueue_job() succeeds
3. Worker job fails (simulated -- the job runs out-of-band)
Verifies: user not stuck at "processing" forever.
Production scenario: ARQ worker crashes -> user gets fallback data.

When queue mode is active, the pipeline:
- Returns a fallback resumo immediately (gerar_resumo_fallback)
- Sets llm_status="processing" to signal the frontend to poll
- Enqueues background LLM + Excel jobs
- Returns the full response without waiting for LLM/Excel
"""

import pytest
from unittest.mock import patch, AsyncMock, Mock
from types import SimpleNamespace

from tests.integration.conftest import make_busca_request

# Use 2+ UFs so the parallel fetch path (buscar_todas_ufs_paralelo) is taken.
_DEFAULT_UFS = ["SP", "RJ", "MG"]


def _make_pncp_result(sample_data):
    """Build a successful PNCP ParallelFetchResult."""
    from pncp_client import ParallelFetchResult
    return ParallelFetchResult(
        items=sample_data,
        succeeded_ufs=["SP", "RJ", "MG"],
        failed_ufs=[],
        truncated_ufs=[],
    )


def _mock_rate_limiter():
    """Create a mock rate limiter that always allows requests."""
    mock = Mock()
    mock.check_rate_limit = AsyncMock(return_value=(True, 0))
    return mock


@pytest.mark.integration
class TestQueueWorkerFailInline:
    """AC12: When queue is available, POST /buscar dispatches background jobs
    and returns immediately with fallback data and llm_status='processing'."""

    def test_queue_mode_returns_llm_status_processing(
        self, integration_app, sample_licitacoes_raw, monkeypatch
    ):
        """When is_queue_available() returns True, the response has
        llm_status='processing' indicating the LLM summary is being
        generated in the background."""
        monkeypatch.setenv("ENABLE_MULTI_SOURCE", "false")

        pncp_result = _make_pncp_result(sample_licitacoes_raw)
        mock_job = Mock()
        mock_job.job_id = "test-job-id"

        with patch(
            "routes.search.buscar_todas_ufs_paralelo",
            new_callable=AsyncMock,
            return_value=pncp_result,
        ), patch(
            "routes.search.rate_limiter",
            _mock_rate_limiter(),
        ), patch(
            "job_queue.is_queue_available",
            new_callable=AsyncMock,
            return_value=True,
        ), patch(
            "job_queue.enqueue_job",
            new_callable=AsyncMock,
            return_value=mock_job,
        ):
            payload = make_busca_request(ufs=_DEFAULT_UFS)
            resp = integration_app.post("/buscar", json=payload)

        assert resp.status_code == 200, (
            f"Expected HTTP 200, got {resp.status_code}: {resp.text}"
        )
        body = resp.json()
        assert body["llm_status"] == "processing", (
            f"Expected llm_status='processing' in queue mode, got '{body.get('llm_status')}'"
        )

    def test_queue_mode_returns_fallback_resumo(
        self, integration_app, sample_licitacoes_raw, monkeypatch
    ):
        """In queue mode, the response includes a fallback resumo
        (generated by gerar_resumo_fallback) so the user sees
        something immediately instead of waiting for the LLM."""
        monkeypatch.setenv("ENABLE_MULTI_SOURCE", "false")

        pncp_result = _make_pncp_result(sample_licitacoes_raw)
        mock_job = Mock()
        mock_job.job_id = "test-job-id"

        with patch(
            "routes.search.buscar_todas_ufs_paralelo",
            new_callable=AsyncMock,
            return_value=pncp_result,
        ), patch(
            "routes.search.rate_limiter",
            _mock_rate_limiter(),
        ), patch(
            "job_queue.is_queue_available",
            new_callable=AsyncMock,
            return_value=True,
        ), patch(
            "job_queue.enqueue_job",
            new_callable=AsyncMock,
            return_value=mock_job,
        ):
            payload = make_busca_request(ufs=_DEFAULT_UFS)
            resp = integration_app.post("/buscar", json=payload)

        body = resp.json()
        resumo = body.get("resumo")
        assert resumo is not None, (
            "Queue mode response must include a fallback resumo"
        )
        assert "resumo_executivo" in resumo, (
            "Fallback resumo must have resumo_executivo field"
        )
        assert len(resumo["resumo_executivo"]) > 0, (
            "Fallback resumo_executivo must be non-empty"
        )

    def test_queue_mode_still_returns_licitacoes(
        self, integration_app, sample_licitacoes_raw, monkeypatch
    ):
        """Even in queue mode, the response must contain the filtered
        licitacoes so the user can browse results while the LLM
        and Excel generation happen in the background."""
        monkeypatch.setenv("ENABLE_MULTI_SOURCE", "false")

        pncp_result = _make_pncp_result(sample_licitacoes_raw)
        mock_job = Mock()
        mock_job.job_id = "test-job-id"

        with patch(
            "routes.search.buscar_todas_ufs_paralelo",
            new_callable=AsyncMock,
            return_value=pncp_result,
        ), patch(
            "routes.search.rate_limiter",
            _mock_rate_limiter(),
        ), patch(
            "job_queue.is_queue_available",
            new_callable=AsyncMock,
            return_value=True,
        ), patch(
            "job_queue.enqueue_job",
            new_callable=AsyncMock,
            return_value=mock_job,
        ):
            payload = make_busca_request(ufs=_DEFAULT_UFS)
            resp = integration_app.post("/buscar", json=payload)

        body = resp.json()
        assert body["total_raw"] > 0, (
            "Queue mode response must report total_raw from the fetch"
        )
        # Licitacoes may be filtered down, but total_raw must reflect the fetch
        assert isinstance(body["licitacoes"], list), (
            "licitacoes must be a list"
        )

    def test_queue_mode_enqueues_llm_and_excel_jobs(
        self, integration_app, sample_licitacoes_raw, monkeypatch
    ):
        """In queue mode, enqueue_job is called at least for the LLM summary.
        If the plan allows Excel, a second enqueue_job call is made for Excel."""
        monkeypatch.setenv("ENABLE_MULTI_SOURCE", "false")

        pncp_result = _make_pncp_result(sample_licitacoes_raw)
        mock_job = Mock()
        mock_job.job_id = "test-job-id"

        mock_enqueue = AsyncMock(return_value=mock_job)

        with patch(
            "routes.search.buscar_todas_ufs_paralelo",
            new_callable=AsyncMock,
            return_value=pncp_result,
        ), patch(
            "routes.search.rate_limiter",
            _mock_rate_limiter(),
        ), patch(
            "job_queue.is_queue_available",
            new_callable=AsyncMock,
            return_value=True,
        ), patch(
            "job_queue.enqueue_job",
            mock_enqueue,
        ):
            payload = make_busca_request(ufs=_DEFAULT_UFS)
            resp = integration_app.post("/buscar", json=payload)

        assert resp.status_code == 200

        # enqueue_job should have been called at least once (LLM job)
        assert mock_enqueue.call_count >= 1, (
            f"enqueue_job should be called at least once for LLM, "
            f"got {mock_enqueue.call_count} calls"
        )

        # Check that the first call was for the LLM summary job
        first_call_args = mock_enqueue.call_args_list[0]
        assert first_call_args[0][0] == "llm_summary_job", (
            f"First enqueue_job call should be for 'llm_summary_job', "
            f"got '{first_call_args[0][0]}'"
        )

        # If Excel is available (professional plan allows it), there should
        # be a second enqueue_job call for excel_generation_job
        if mock_enqueue.call_count >= 2:
            second_call_args = mock_enqueue.call_args_list[1]
            assert second_call_args[0][0] == "excel_generation_job", (
                f"Second enqueue_job call should be for 'excel_generation_job', "
                f"got '{second_call_args[0][0]}'"
            )
